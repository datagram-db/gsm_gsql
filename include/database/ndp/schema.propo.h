// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: schema.propo

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 2000000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(e204b13ae714e1b2);
CAPNP_DECLARE_SCHEMA(9ab3e59386e6f925);
CAPNP_DECLARE_SCHEMA(deb1bf39fb7e11dc);
CAPNP_DECLARE_SCHEMA(ffe96e5f9297bf26);
CAPNP_DECLARE_SCHEMA(f2720fbacd3da82a);
CAPNP_DECLARE_SCHEMA(bdf7b4dab825adb6);

}  // namespace schemas
}  // namespace capnp


template <typename Key = ::capnp::AnyPointer, typename Value = ::capnp::AnyPointer>
struct Map {
  Map() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Entry;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e204b13ae714e1b2, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename Key, typename Value>
struct Map<Key, Value>::Entry {
  Entry() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ab3e59386e6f925, 0, 2)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, Key, Value>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Value {
  Value() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Val;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(deb1bf39fb7e11dc, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Value::Val {
  Val() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    STR,
    FLT,
    VAL,
    BOL,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffe96e5f9297bf26, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GSMObjectContent {
  GSMObjectContent() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f2720fbacd3da82a, 2, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct GSMObject {
  GSMObject() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(bdf7b4dab825adb6, 1, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

template <typename Key, typename Value>
class Map<Key, Value>::Reader {
public:
  typedef Map Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Reader asGeneric() {
    return typename Map<Key2, Value2>::Reader(_reader);
  }

  inline bool hasEntries() const;
  inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Builder {
public:
  typedef Map Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Builder asGeneric() {
    return typename Map<Key2, Value2>::Builder(_builder);
  }

  inline bool hasEntries();
  inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries(typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Pipeline {
public:
  typedef Map Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Reader {
public:
  typedef Entry Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Entry::Reader asMapGeneric() {
    return typename Map<Key2, Value2>::Entry::Reader(_reader);
  }

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<Key> getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<Value> getValue() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename Key, typename Value>
class Map<Key, Value>::Entry::Builder {
public:
  typedef Entry Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename Key2 = ::capnp::AnyPointer, typename Value2 = ::capnp::AnyPointer>
  typename Map<Key2, Value2>::Entry::Builder asMapGeneric() {
    return typename Map<Key2, Value2>::Entry::Builder(_builder);
  }

  inline bool hasKey();
  inline  ::capnp::BuilderFor<Key> getKey();
  inline void setKey( ::capnp::ReaderFor<Key> value);
  inline  ::capnp::BuilderFor<Key> initKey();
  inline  ::capnp::BuilderFor<Key> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<Key>&& value);
  inline ::capnp::Orphan<Key> disownKey();

  inline bool hasValue();
  inline  ::capnp::BuilderFor<Value> getValue();
  inline void setValue( ::capnp::ReaderFor<Value> value);
  inline  ::capnp::BuilderFor<Value> initValue();
  inline  ::capnp::BuilderFor<Value> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<Value>&& value);
  inline ::capnp::Orphan<Value> disownValue();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename Key, typename Value>
class Map<Key, Value>::Entry::Pipeline {
public:
  typedef Entry Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<Key> getKey();
  inline  ::capnp::PipelineFor<Value> getValue();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Value::Reader {
public:
  typedef Value Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline typename Val::Reader getVal() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Value::Builder {
public:
  typedef Value Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline typename Val::Builder getVal();
  inline typename Val::Builder initVal();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Value::Pipeline {
public:
  typedef Value Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline typename Val::Pipeline getVal();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Value::Val::Reader {
public:
  typedef Val Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isStr() const;
  inline bool hasStr() const;
  inline  ::capnp::Text::Reader getStr() const;

  inline bool isFlt() const;
  inline double getFlt() const;

  inline bool isVal() const;
  inline  ::int64_t getVal() const;

  inline bool isBol() const;
  inline bool getBol() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Value::Val::Builder {
public:
  typedef Val Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isStr();
  inline bool hasStr();
  inline  ::capnp::Text::Builder getStr();
  inline void setStr( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initStr(unsigned int size);
  inline void adoptStr(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownStr();

  inline bool isFlt();
  inline double getFlt();
  inline void setFlt(double value);

  inline bool isVal();
  inline  ::int64_t getVal();
  inline void setVal( ::int64_t value);

  inline bool isBol();
  inline bool getBol();
  inline void setBol(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Value::Val::Pipeline {
public:
  typedef Val Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GSMObjectContent::Reader {
public:
  typedef GSMObjectContent Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasScores() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getScores() const;

  inline  ::uint64_t getOrigEdgeId() const;

  inline bool hasPi() const;
  inline  ::Map< ::capnp::Text,  ::Value>::Reader getPi() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GSMObjectContent::Builder {
public:
  typedef GSMObjectContent Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasScores();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getScores();
  inline void setScores( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setScores(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initScores(unsigned int size);
  inline void adoptScores(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownScores();

  inline  ::uint64_t getOrigEdgeId();
  inline void setOrigEdgeId( ::uint64_t value);

  inline bool hasPi();
  inline  ::Map< ::capnp::Text,  ::Value>::Builder getPi();
  inline void setPi( ::Map< ::capnp::Text,  ::Value>::Reader value);
  inline  ::Map< ::capnp::Text,  ::Value>::Builder initPi();
  inline void adoptPi(::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>>&& value);
  inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>> disownPi();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GSMObjectContent::Pipeline {
public:
  typedef GSMObjectContent Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Map< ::capnp::Text,  ::Value>::Pipeline getPi();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class GSMObject::Reader {
public:
  typedef GSMObject Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId() const;

  inline bool hasEll() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getEll() const;

  inline bool hasXi() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getXi() const;

  inline bool hasScores() const;
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader getScores() const;

  inline bool hasContent() const;
  inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Reader getContent() const;

  inline bool hasPi() const;
  inline  ::Map< ::capnp::Text,  ::Value>::Reader getPi() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class GSMObject::Builder {
public:
  typedef GSMObject Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getId();
  inline void setId( ::uint64_t value);

  inline bool hasEll();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getEll();
  inline void setEll( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setEll(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initEll(unsigned int size);
  inline void adoptEll(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownEll();

  inline bool hasXi();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getXi();
  inline void setXi( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setXi(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initXi(unsigned int size);
  inline void adoptXi(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownXi();

  inline bool hasScores();
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder getScores();
  inline void setScores( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setScores(::kj::ArrayPtr<const double> value);
  inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder initScores(unsigned int size);
  inline void adoptScores(::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> disownScores();

  inline bool hasContent();
  inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Builder getContent();
  inline void setContent( ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Reader value);
  inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Builder initContent();
  inline void adoptContent(::capnp::Orphan< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>&& value);
  inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>> disownContent();

  inline bool hasPi();
  inline  ::Map< ::capnp::Text,  ::Value>::Builder getPi();
  inline void setPi( ::Map< ::capnp::Text,  ::Value>::Reader value);
  inline  ::Map< ::capnp::Text,  ::Value>::Builder initPi();
  inline void adoptPi(::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>>&& value);
  inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>> disownPi();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class GSMObject::Pipeline {
public:
  typedef GSMObject Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Pipeline getContent();
  inline  ::Map< ::capnp::Text,  ::Value>::Pipeline getPi();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

template <typename Key, typename Value>
inline bool Map<Key, Value>::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader Map<Key, Value>::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder Map<Key, Value>::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::setEntries(typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline typename  ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>::Builder Map<Key, Value>::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>> Map<Key, Value>::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::Map<Key, Value>::Entry,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Key> Map<Key, Value>::Entry::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<Key>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::getKey() {
  return ::capnp::_::PointerHelpers<Key>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Key> Map<Key, Value>::Entry::Pipeline::getKey() {
  return  ::capnp::PipelineFor<Key>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setKey( ::capnp::ReaderFor<Key> value) {
  ::capnp::_::PointerHelpers<Key>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey() {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Key> Map<Key, Value>::Entry::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<Key>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptKey(
    ::capnp::Orphan<Key>&& value) {
  ::capnp::_::PointerHelpers<Key>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Key> Map<Key, Value>::Entry::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<Key>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline bool Map<Key, Value>::Entry::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename Key, typename Value>
inline  ::capnp::ReaderFor<Value> Map<Key, Value>::Entry::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<Value>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::getValue() {
  return ::capnp::_::PointerHelpers<Value>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename Key, typename Value>
inline  ::capnp::PipelineFor<Value> Map<Key, Value>::Entry::Pipeline::getValue() {
  return  ::capnp::PipelineFor<Value>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::setValue( ::capnp::ReaderFor<Value> value) {
  ::capnp::_::PointerHelpers<Value>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue() {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename Key, typename Value>
inline  ::capnp::BuilderFor<Value> Map<Key, Value>::Entry::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<Value>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename Key, typename Value>
inline void Map<Key, Value>::Entry::Builder::adoptValue(
    ::capnp::Orphan<Value>&& value) {
  ::capnp::_::PointerHelpers<Value>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename Key, typename Value>
inline ::capnp::Orphan<Value> Map<Key, Value>::Entry::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<Value>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

// Map<Key, Value>::Entry
#if !CAPNP_LITE
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::Entry::_capnpPrivate::brandScopes[] = {
  { 0xe204b13ae714e1b2, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::Entry::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::Entry::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9ab3e59386e6f925, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// Map<Key, Value>
#if !CAPNP_LITE
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Scope Map<Key, Value>::_capnpPrivate::brandScopes[] = {
  { 0xe204b13ae714e1b2, brandBindings + 0, 2, false},
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Binding Map<Key, Value>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<Key>(),
  ::capnp::_::brandBindingFor<Value>(),
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema::Dependency Map<Key, Value>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::Map<Key, Value>::Entry::_capnpPrivate::brand() },
};
template <typename Key, typename Value>
const ::capnp::_::RawBrandedSchema Map<Key, Value>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_e204b13ae714e1b2, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

inline typename Value::Val::Reader Value::Reader::getVal() const {
  return typename Value::Val::Reader(_reader);
}
inline typename Value::Val::Builder Value::Builder::getVal() {
  return typename Value::Val::Builder(_builder);
}
#if !CAPNP_LITE
inline typename Value::Val::Pipeline Value::Pipeline::getVal() {
  return typename Value::Val::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
inline typename Value::Val::Builder Value::Builder::initVal() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<0>() * ::capnp::POINTERS).clear();
  return typename Value::Val::Builder(_builder);
}
inline  ::Value::Val::Which Value::Val::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::Value::Val::Which Value::Val::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Value::Val::Reader::isStr() const {
  return which() == Value::Val::STR;
}
inline bool Value::Val::Builder::isStr() {
  return which() == Value::Val::STR;
}
inline bool Value::Val::Reader::hasStr() const {
  if (which() != Value::Val::STR) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Value::Val::Builder::hasStr() {
  if (which() != Value::Val::STR) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Value::Val::Reader::getStr() const {
  KJ_IREQUIRE((which() == Value::Val::STR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Value::Val::Builder::getStr() {
  KJ_IREQUIRE((which() == Value::Val::STR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Value::Val::Builder::setStr( ::capnp::Text::Reader value) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::STR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Value::Val::Builder::initStr(unsigned int size) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::STR);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Value::Val::Builder::adoptStr(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::STR);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Value::Val::Builder::disownStr() {
  KJ_IREQUIRE((which() == Value::Val::STR),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Value::Val::Reader::isFlt() const {
  return which() == Value::Val::FLT;
}
inline bool Value::Val::Builder::isFlt() {
  return which() == Value::Val::FLT;
}
inline double Value::Val::Reader::getFlt() const {
  KJ_IREQUIRE((which() == Value::Val::FLT),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Value::Val::Builder::getFlt() {
  KJ_IREQUIRE((which() == Value::Val::FLT),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Val::Builder::setFlt(double value) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::FLT);
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Val::Reader::isVal() const {
  return which() == Value::Val::VAL;
}
inline bool Value::Val::Builder::isVal() {
  return which() == Value::Val::VAL;
}
inline  ::int64_t Value::Val::Reader::getVal() const {
  KJ_IREQUIRE((which() == Value::Val::VAL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int64_t Value::Val::Builder::getVal() {
  KJ_IREQUIRE((which() == Value::Val::VAL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Value::Val::Builder::setVal( ::int64_t value) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::VAL);
  _builder.setDataField< ::int64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Value::Val::Reader::isBol() const {
  return which() == Value::Val::BOL;
}
inline bool Value::Val::Builder::isBol() {
  return which() == Value::Val::BOL;
}
inline bool Value::Val::Reader::getBol() const {
  KJ_IREQUIRE((which() == Value::Val::BOL),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool Value::Val::Builder::getBol() {
  KJ_IREQUIRE((which() == Value::Val::BOL),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void Value::Val::Builder::setBol(bool value) {
  _builder.setDataField<Value::Val::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Value::Val::BOL);
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t GSMObjectContent::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t GSMObjectContent::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GSMObjectContent::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GSMObjectContent::Reader::hasScores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObjectContent::Builder::hasScores() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader GSMObjectContent::Reader::getScores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder GSMObjectContent::Builder::getScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GSMObjectContent::Builder::setScores( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void GSMObjectContent::Builder::setScores(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder GSMObjectContent::Builder::initScores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GSMObjectContent::Builder::adoptScores(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> GSMObjectContent::Builder::disownScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::uint64_t GSMObjectContent::Reader::getOrigEdgeId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t GSMObjectContent::Builder::getOrigEdgeId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void GSMObjectContent::Builder::setOrigEdgeId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool GSMObjectContent::Reader::hasPi() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObjectContent::Builder::hasPi() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::Map< ::capnp::Text,  ::Value>::Reader GSMObjectContent::Reader::getPi() const {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::Map< ::capnp::Text,  ::Value>::Builder GSMObjectContent::Builder::getPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Map< ::capnp::Text,  ::Value>::Pipeline GSMObjectContent::Pipeline::getPi() {
  return  ::Map< ::capnp::Text,  ::Value>::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void GSMObjectContent::Builder::setPi( ::Map< ::capnp::Text,  ::Value>::Reader value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::Map< ::capnp::Text,  ::Value>::Builder GSMObjectContent::Builder::initPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GSMObjectContent::Builder::adoptPi(
    ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>>&& value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>> GSMObjectContent::Builder::disownPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline  ::uint64_t GSMObject::Reader::getId() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t GSMObject::Builder::getId() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void GSMObject::Builder::setId( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool GSMObject::Reader::hasEll() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObject::Builder::hasEll() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader GSMObject::Reader::getEll() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder GSMObject::Builder::getEll() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void GSMObject::Builder::setEll( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void GSMObject::Builder::setEll(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder GSMObject::Builder::initEll(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void GSMObject::Builder::adoptEll(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> GSMObject::Builder::disownEll() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool GSMObject::Reader::hasXi() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObject::Builder::hasXi() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader GSMObject::Reader::getXi() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder GSMObject::Builder::getXi() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void GSMObject::Builder::setXi( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline void GSMObject::Builder::setXi(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder GSMObject::Builder::initXi(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void GSMObject::Builder::adoptXi(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> GSMObject::Builder::disownXi() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool GSMObject::Reader::hasScores() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObject::Builder::hasScores() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader GSMObject::Reader::getScores() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder GSMObject::Builder::getScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void GSMObject::Builder::setScores( ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline void GSMObject::Builder::setScores(::kj::ArrayPtr<const double> value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>::Builder GSMObject::Builder::initScores(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void GSMObject::Builder::adoptScores(
    ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>> GSMObject::Builder::disownScores() {
  return ::capnp::_::PointerHelpers< ::capnp::List<double,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool GSMObject::Reader::hasContent() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObject::Builder::hasContent() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Reader GSMObject::Reader::getContent() const {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Builder GSMObject::Builder::getContent() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Pipeline GSMObject::Pipeline::getContent() {
  return  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void GSMObject::Builder::setContent( ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Reader value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>::Builder GSMObject::Builder::initContent() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void GSMObject::Builder::adoptContent(
    ::capnp::Orphan< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>&& value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>> GSMObject::Builder::disownContent() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::capnp::List< ::GSMObjectContent,  ::capnp::Kind::STRUCT>>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool GSMObject::Reader::hasPi() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool GSMObject::Builder::hasPi() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::Map< ::capnp::Text,  ::Value>::Reader GSMObject::Reader::getPi() const {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::Map< ::capnp::Text,  ::Value>::Builder GSMObject::Builder::getPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::Map< ::capnp::Text,  ::Value>::Pipeline GSMObject::Pipeline::getPi() {
  return  ::Map< ::capnp::Text,  ::Value>::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void GSMObject::Builder::setPi( ::Map< ::capnp::Text,  ::Value>::Reader value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::Map< ::capnp::Text,  ::Value>::Builder GSMObject::Builder::initPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void GSMObject::Builder::adoptPi(
    ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>>&& value) {
  ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::Map< ::capnp::Text,  ::Value>> GSMObject::Builder::disownPi() {
  return ::capnp::_::PointerHelpers< ::Map< ::capnp::Text,  ::Value>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}


CAPNP_END_HEADER

