p1 = (X)--[l:det||nmod_poss||amod||mark||case||punct]->(Y)                   // Graph matching, First pattern
      where ((TEST "|varphi (var(\"Y\"))| == 0") ‚àß ((Y unmatched p2 . K) ‚àß (Y unmatched p3 . T)))
     ‚Ü™  set (ùúã (label l) @ X) as (ùúâ 0 @ Y)                        // Property extension
       del Y                                             // Removing a node

       (X);                                              // Instance of reference to be returned

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

p2 = (>> H)<-[‚àÄl:]--(X)                                   // Graph matching, Second pattern
           --[conj] hook
           --[? case]->(K)
           --[? c : cc]->(Z)
           --[? g:]->(Y)
    //where ((Y unmatched p4 . V) ‚àß ((Y unmatched p2 . X) ‚àß (Y unmatched p3 . V)))
     ‚Ü™  new h                                             // Creating a new node standing for H
       set (œÜ orig , h) as H                             // This node will contain all the grouped element (>>)
       set (ùúã conj @ h) as (ùúâ 0 @ Z)                     // Optional, only if Z exists!
       set (ùúâ 0 @ h) as (ùúâ 0 @ H)
       set (œÜ (if ((label l ) = nmod) then    // Defining the label in function of K, if this exists,
                                                                      // otherwise using l
                                       (ùúâ 0 @ K)
                                      else
                                       (label l)
                                      ), X) as h
       /*set (œÜ (label g), h) as Y*/
       del Z
       del K
       del l


     (h)
        ;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

p3 = (V)--[‚àÄn:nsubj]->(>>S)
        --[? mark]->(M)
        --[? aux]->(A)
        --[‚àÄl:dobj||ccomp||nmod]->(>>Z) // Future work: nested join between >>Z and >>Z from the join, when required. This might require to re-do the join semantics
     (Z)--[? case]->(T)

     ‚Ü™
        //new s
        set(œÜ (if ((label l ) = nmod) then    // Defining the label in function of T, if this exists,
                                                                      // otherwise using V
                                              SCRIPT "((xi var(\"A\"))[0]) ++ \" \" ++ ((xi var(\"V\"))[0]) ++ \" \" ++ ((xi var(\"T\"))[0])"
                                             else
                                              SCRIPT "((xi var(\"A\"))[0]) ++ \" \" ++ ((xi var(\"V\"))[0])"
                                             ), S) as Z
        //set(   ùúã mark @ s) as (ùúâ 0 @ M)
        //set(   œÜ orig , s) as S
        //set(   ùúâ 0 @ s) as (ùúâ 0 @ S)
       del V
       del T
       del M

       (S) ;

p4 = (V)--[‚àÄl:dobj||ccomp||nmod]->(Z)
      (Z)--[? case]->(T)
      where ((V unmatched p3 . V))
     ‚Ü™  new j
        set(œÜ (if ((label l ) = nmod) then    // Defining the label in function of T, if this exists,
                                                                              // otherwise using V
                                                      SCRIPT "((xi var(\"V\"))[0]) ++ \" \" ++ ((xi var(\"T\"))[0])"
                                                     else
                                                      (ùúâ 0 @ V)
                                                     ), j) as Z
       del V                                             // Removing a node
       del T

       (j)                                              // Instance of reference to be returned

