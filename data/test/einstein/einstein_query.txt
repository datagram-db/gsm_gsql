p1 = (X)--[l:det||nmod_poss||amod||mark||case||punct||advmod||advcl||cc||dep]->(Y)                   // Graph matching, First pattern
      where ((TEST "= |ğœ‘ â¦ƒ\"Y\"â¦„ | 0 ") âˆ§ ((Y unmatched p2 . K) âˆ§ ((Y unmatched p3 . T) âˆ§ ((Y unmatched p2 . Z) âˆ§ ((â„“ 0 @ Y â‰  noun) âˆ§ (â„“ 0 @ Y â‰  verb))))))
     â†ª  set (ğœ‹ (label l) @ X) as (ğœ‰ 0 @ Y)                        // Property extension
       del Y                                             // Removing a node

       (X);                                              // Instance of reference to be returned

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

p2 = (>> H)<-[âˆ€l:]--(X)                                   // Graph matching, Second pattern
           --[conj] hook
           --[? case]->(K)
           --[? c : cc]->(Z)
           //--[? g:]->(Y)
    //where ((Y unmatched p4 . V) âˆ§ ((Y unmatched p2 . X) /*âˆ§ (Y unmatched p3 . V)*/))
     â†ª  new h                                             // Creating a new node standing for H
       set (Ï† orig , h) as H                             // This node will contain all the grouped element (>>)
       set (ğœ‹ conj @ h) as (ğœ‰ 0 @ Z)                     // Optional, only if Z exists!
       set (ğœ‰ 0 @ h) as (ğœ‰ 0 @ H)
       set (Ï† (if ((label l ) = nmod) over l then    // Defining the label in function of K, if this exists,
                                                                      // otherwise using l
                                       (ğœ‰ 0 @ K)
                                      else
                                       (label l)
                                      ), X) as h
       del Z
       del K
       del l


       (h);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

p3fauxcop = (V)--[âˆ€n:nsubj]->(S)
               --[aux]->(A)
            where ((( FILL ( ğœ‹ lemma @ A )= be )) âˆ§ ((V unmatched p4 . V) âˆ§((V unmatched p3 . V) âˆ§ ((V unmatched p3pass . V) âˆ§ ((V unmatched p3expl . V) âˆ§((â„“ 0 @ V = verb)))))))
â†ª set (ğœ‹ cop @ S) as (ğœ‰ 0 @ V)                        // Property extension
         del A                                             // Removing a node
         del V
         (S);                                              // Instance of reference to be returned


p3simple = (V)--[âˆ€n:nsubj]->(>>S)
        --[? mark]->(M)
        --[? aux]->(A)
        --[? neg]->(N)
        --[âˆ€l:dobj||ccomp||nmod]->(>>Z) // Future work: nested join between >>Z and >>Z from the join, when required. This might require to re-do the join semantics
     (Z)--[? case]->(T)
     â†ª
        //new s
        set(Ï† (SCRIPT "(^(^(^(^ (^ ( [(ğœ‰ â¦ƒ\"A\"â¦„) 0])  \" \") ([ (ğœ‰ â¦ƒ\"N\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"V\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"T\"â¦„)  0])") , S) as Z
        //set(   ğœ‹ mark @ s) as (ğœ‰ 0 @ M)
        //set(   Ï† orig , s) as S
        //set(   ğœ‰ 0 @ s) as (ğœ‰ 0 @ S)
       del V
       del T
       del M

       (S) ;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // This matches any direct clause with subject and (in)direct object.
    // Still, we want to avoid having multiple matches: the idea is to group them by as in 4.
    
p3 = (>> V)<-[âˆ€ ? w:]--(B)
        --[n:nsubj]->(>> S)
        --[? mark]->(M)
        --[? aux]->(A)
        --[? neg]->(N)
        --[? expl]->(E)
        --[? iobj]->(IOZ)
        --[? advmod||advcl]->(>> ADM)
        //--[? xcomp]->(XC)
        --[âˆ€ ge: dobj||ccomp||nmod||dep||obj||obl||xcomp]->( Z) // Future work: nested join between >>Z and >>Z from the join, when required. This might require to re-do the join semantics
     (Z)--[? case]->(T)
     (S)--[? neg]->(NN)
     where ((V unmatched p3pass . V) âˆ§ ((V unmatched p3expl . V) âˆ§((â„“ 0 @ V = verb))))
     â†ª
        //new s
        set(Ï† (SCRIPT "[(Â° (fun y â†’ { l cp (fun x â†’ { ^ (^ ([â¦ƒxâ¦„ 0]) \" \") ([â¦ƒxâ¦„ 1]) }) (\" \")  y } ) ( zip ( a {   (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.A\"â¦„)  ; (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.N\"â¦„) ;  (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.V\"â¦„) ; (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.T\"â¦„) } ) )) 0]"), S) as Z
        //set(   ğœ‹ mark @ s) as (ğœ‰ 0 @ M)
        //set(   Ï† orig , s) as S
        //set(   ğœ‰ 0 @ s) as (ğœ‰ 0 @ S)
        set(ğœ‹ expl @ S) as (â„“ 0 @ E)
       set (Ï† iobj , S) as IOZ
       set (Ï† adv , S) as ADM
       set (Ï† dep , S) as Z
       del V
       del T
       del M
       del A
       del E
       del NN
       (S);

p3expl = (V)--[âˆ€n:nsubj]->(>> S)
        --[? mark]->(M)
        --[? aux]->(A)
        --[? neg]->(N)
        --[? iobj]->(IOW)
        --[? advmod||advcl]->(>> ADM)
        --[? xcomp||dep]->(XC)
        --[l:expl]->(>> Z) // Future work: nested join between >>Z and >>Z from the join, when required. This might require to re-do the join semantics
     (Z)--[? case]->(T)
     (S)--[? neg]->(NN)
     //(S)--[nmod]->(C)
     where (((â„“ 0 @ V = verb)))
     â†ª
        //new s
        set(Ï† (if ((label l ) = nmod) over l then    // Defining the label in function of T, if this exists,
                                                                      // otherwise using V
                                              SCRIPT "(^(^(^(^(^(^ (^ ( [(ğœ‰ â¦ƒ\"A\"â¦„) 0])  \" \") ([ (ğœ‰ â¦ƒ\"N\"â¦„)  0])) \" \") ([ (ğœ‰ ([â¦ƒ\"S.NN\"â¦„ 0]))  0])) \" \") ([ (ğœ‰ â¦ƒ\"V\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"T\"â¦„)  0])"
                                             else
                                              SCRIPT "^(^(^ (^(^(^ ( [(ğœ‰ â¦ƒ\"A\"â¦„) 0])  \" \") ([ (ğœ‰ â¦ƒ\"N\"â¦„)  0])) \" \") ([ (ğœ‰ ([â¦ƒ\"S.NN\"â¦„ 0]))  0])) \" \") ([ (ğœ‰ â¦ƒ\"V\"â¦„)  0])"
                                             ), S) as Z
        set(ğœ‹ expl @ S) as (â„“ 0 @ Z)
       set (Ï† iobj , S) as IOW
       set (ğœ‹ adv @ S) as (ğœ‰ 0 @ ADM)
      set (Ï† dep , S) as XC
       del V
       del T
       del M
       del A
       del NN
       del ADM
       (S);

p3pass = (V)--[âˆ€n:nsubjpass]->(>> S)
        --[? mark]->(M)
        --[? auxpass]->(A)
        --[? neg]->(N)
        --[? expl]->(E)
        --[? iobj]->(IOB)
        --[? advmod||advcl]->(>> ADM)
       // --[? xcomp]->(XC)
        --[? l:ccomp||nmod||dep||xcomp]->(Z) // Future work: nested join between >>Z and >>Z from the join, when required. This might require to re-do the join semantics
     (Z)--[? case]->(T)
     (S)--[? neg]->(NN)
     where ((V unmatched p3expl . V) âˆ§ (â„“ 0 @ V = verb))
     â†ª
        //new s
        set(Ï† (if ((label l ) = nmod) over l then    // Defining the label in function of T, if this exists,
                                                                      // otherwise using V
                                              SCRIPT "(^(^(^(  ([ (ğœ‰ â¦ƒ\"N\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"V\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"T\"â¦„)  0])"
                                             else
                                              SCRIPT "^(^( ([ (ğœ‰ â¦ƒ\"N\"â¦„)  0])) \" \") ([ (ğœ‰ â¦ƒ\"V\"â¦„)  0])"
                                             ), Z) as S
        //set(   ğœ‹ mark @ s) as (ğœ‰ 0 @ M)
        //set(   Ï† orig , s) as S
        //set(   ğœ‰ 0 @ s) as (ğœ‰ 0 @ S)
       set (Ï† iobj , Z) as IOB
       set (ğœ‹ adv @ Z) as (ğœ‰ 0 @ ADM)
       //set (Ï† dep , Z) as XC
        set(ğœ‹ expl @ s) as (â„“ 0 @ E)
       del V
       del T
       del M
       del A
       del E
       del NN
       del ADM
       (S);

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

       // Case matching the sentences having no subject!
p4 = (>> V)<-[âˆ€ ? w:]--(B)
        --[âˆ€l:dobj||ccomp||nmod||dep||obj||xcomp]->(Z)
        --[? nmod_tmod]->(TN)
        --[? expl]->(E)
        --[? iobj]->(IOA)
        --[? advmod||advcl]->(>> ADM)
        --[? compound_ptr]->(TB)
     (Z)--[? case]->(T)
      where ((V unmatched p3 . V) âˆ§ ((V unmatched p3pass . V) âˆ§ ((V unmatched p3expl3 . V) âˆ§ (â„“ 0 @ V = verb))))
     â†ª  new j
        set(Ï† when , j) as TN
        set(ğœ‹ expl @ j) as (â„“ 0 @ E)
       set (ğœ‹ adv @ j) as (ğœ‰ 0 @ ADM)
       set (Ï† iobj , j) as IOA
       //set (Ï† dep , j) as XC
        set(Ï† (if ((label l ) = nmod) over l then    // Defining the label in function of T, if this exists,
                                                                              // otherwise using V
                                                      SCRIPT "Â° (fun y â†’ { l cp (fun x â†’ { ^ (^ ([â¦ƒxâ¦„ 0]) \" \") ([â¦ƒxâ¦„ 1]) }) (\" \")  y } ) ( zip ( a {   (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.V\"â¦„)  ; (Â° (fun y â†’ {[(ğœ‰ y) 0]}) â¦ƒ\"*.T\"â¦„) } ))"
                                                     else
                                                      (ğœ‰ 0 @ V)
                                                     ), j) as Z
       del V                                             // Removing a node
       del T
       del E
       del ADM
       (j)                                              // Instance of reference to be returned


